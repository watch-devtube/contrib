# Contribution guide: https://github.com/watch-devtube/contrib

# speaker:
#   name: _____
#   twitter: _____ # mandatory twitter handle; must not include @

# tags: [____, _____, _____]

tags:
    - ux
    - mobile
    - android
    - architecture
    - java
    - functional
title: 'CoffeeBeam A BEAM VM for Android'
language: English
recordingDate: 1601795067
description: "by Viktor Gergely\n\nAt: FOSDEM 2020\nhttps://video.fosdem.org/2020/AW1.121/beam_coffeebeam_beam_vm_android.webm\n\nThe speaker started to experiment with running BEAM modules on Android during summer of 2019. A prototype called CoffeeBeam has been created that is capable of loading and running BEAM files on Android. The solution also contains a virtual machine that provides a lightweight Erlang runtime system. Most of the implemented functionality is independent of the source language of the BEAM files, so the platform is easily extensible to support further languages on the BEAM. During the talk, the speaker is going to present a real-life example of running a BEAM file on Android, while presenting the concepts of the implementation and sharing the story of this journey.\n❮h1❯CoffeeBeam: a BEAM VM for Android❮/h1❯\n\n❮h2❯Goal❮/h2❯\n\nCoffeeBeam is a lightweight Erlang virtual machine that provides easy integration of BEAM files with Android applications. The current alternative solutions provide almost fully functional Erlang runtime systems in the form of Erlang shell on Android devices. However, CoffeeBeam follows a different approach, targeting easy integration of pre-compiled BEAM files into standalone Android applications. The characteristics of Android devices are in focus: they provide large amount of memory while CPU usage needs to be optimized to provide longer device lifetime. It is preferred to make the communication between Erlang and the Android application transparent to provide better user experience.\n\n\n❮h2❯Use Case❮/h2❯\n\nLet's assume that you chose a language over the BEAM to implement an application logic efficiently. CoffeeBeam provides a framework to build on this logic and enable communication between the BEAM and the Android application with only minor changes to your original code. The demonstrated example is a ❮code❯TicTacToe❮/code❯ game where the game logic is implemented in Erlang that is extended with a graphical user interface implemented as an Android activity in Java.\n\n\n❮h2❯Application Architecture❮/h2❯\n\n❮h3❯Android Activity❮/h3❯\n\nThe ❮code❯TicTacToe❮/code❯ game is implemented as an Android activity which is a common way of creating interactive applications. The activity contains the view for displaying textual information (game name and user instructions depending on the state of the game) and widgets (game board and new game button) for initiating user actions towards the game logic.\n\n\n❮h3❯CoffeeBeam VM❮/h3❯\n\nThe CoffeBeam VM provides the runtime system for the game logic. It is written in Java and included as a ❮code❯.jar❮/code❯ library inside the Android application source code. Starting and stopping the VM is connected to the ❮code❯onCreate()❮/code❯ and ❮code❯onDestroy()❮/code❯ callbacks of the activity.\n\n\n❮h3❯Game logic❮/h3❯\n\nThe flow of the game and the computer player's intelligence is implemented as an Erlang module (approximately 250 lines of code) and the compiled ❮code❯.beam❮/code❯ file is packaged into the Android application as resource.\n\n\n❮h2❯Communication❮/h2❯\n\nThe ❮code❯BeamClient❮/code❯ class provides interface for starting and stopping the VM, and manages communication between the VM and the Android application through function calls and callback functions. The default behavior can be redefined by extending the ❮code❯BeamClient❮/code❯ class. The forms of communication are described in detail below.\n\n\n❮h3❯Function call in the VM❮/h3❯\n\nUser actions in the Android application are translated into function calls in the VM using the ❮code❯apply(String module, String function, ErlList args)❮/code❯ method of the ❮code❯BeamClient❮/code❯ class. The function call implies creating a new process in the Erlang VM and applying ❮code❯module:function❮/code❯ with the list of ❮code❯args❮/code❯. The ❮code❯TicTacToe❮/code❯ game logic provides the following functions:\n\n\n❮ul❯\n❮li❯Start the game process: ❮code❯start()❮/code❯. The game process is spawned that initializes the board for a new game.❮/li❯\n❮li❯Start a new game: ❮code❯new_game(GamePid)❮/code❯. The game board is cleared and a new game starts in the game process identified by ❮code❯GamePid❮/code❯.❮/li❯\n❮li❯The player selects a field: ❮code❯put(GamePid, X, Y)❮/code❯. The player marks the ❮code❯(X,Y)❮/code❯ field of the game board with an ❮code❯X❮/code❯ sign.❮/li❯\n❮/ul❯\n\n\n❮h3❯Handle function result in Android❮/h3❯\n\nWhen the Erlang function is executed in the VM, the result of the function initiates a callback in the ❮code❯BeamClient❮/code❯ as ❮code❯handleResult(ErlTerm result)❮/code❯. In the ❮code❯TicTacToe❮/code❯ example, the process identifier of the game process is returned as the result of the ❮code❯tictactoe:start()❮/code❯ function. The returned value can be used to send Erlang messages to the game process during the game.\n\n\n❮h3❯Handle function callback in Android❮/h3❯\n\nEach call in the form of ❮code❯beamclient:function(arg)❮/code❯ in the Erlang modules results in a ❮code❯BeamClient❮/code❯ callback ❮code❯handleCall(String functio…"
