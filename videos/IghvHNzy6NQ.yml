# Editing guidelines: https://github.com/watch-devtube/contrib/#how-to-edit-video-metadata

category: conference
tags:
    - performance
    - architecture
title: 'Lambda Days -  Daniel Rubio Bonilla - (...) Large Scale, Strongly Heterogeneous Infrastructures'
language: English
recordingDate: 1396447769
description: 'Parallel and portable development of programs is an increasingly important subject for usage of future computing systems. With the increasing parallelism and divergence of processor types, such as GPUs and FPGAs, the need for an integrated programming model becomes increasingly important. Simultaneously, a major paradigm shift from compute centric to communication centric execution has arisen but classical models are geared towards optimizing the computational operations, assuming data access is free. C-like languages have a lack of consideration for data access and communication cost and assume that variables are immediately available. This is the reason that compilers usually have to take the most pessimistic approach to data access as most programming models do not convey data dependency information. Dataflow models focus on how data is processed by the application, incorporating the data dependency information relevant for parallelization. For this reason dataflow models are getting attention from HPC (High Performance Computing), as they allow out-of-order execution, increasing resource utilization, while data dependencies are fulfilled. But it has some drawbacks that limit their usability and efficiency. For example, specifying the dataflow is not intuitive as the developer has to abstract from the procedural description of the application and think about data dependencies. Also typical dataflow models have no notion of the relationship between computational complexity and the communication cost, that could lead to bad parallelization. In HPC most compute intensive algorithms are mathematical, but they are generally developed in an imperative languages, because functional languages do not align well with turing-based processor architecture and its characteristics, such as memory constraints. To improve this situation the POLCA project proposes a new Language Model that uses mathematical declarations (using Clash, a modified version of Haskell) attached to the imperative language kernels. Looking at the mathematics of the problem, POLCA is able to apply axioms to generate different views of the same problem without affecting correctness, transforming the original problem into an equivalent and, from it, derive the dependency graph. Using the dependency graph, the dataflow can easily be derived and used for temporal and spatial reasoning. With these transformations and the graph information we can increase parallelism, execute the algorithm''s tasks out of order and with a better match to the underlying system (and potentially also be able to change the memory and communication load), as the only factual constraint for execution arising from the logical structure is that no single task can be executed before its incoming edges, the input data, have been produced. The imperative code is transformed using the reasoning of the functional annotations, and later compiled into binary for conventional CPUs (turing-based processors), keeping its main advantage over functional languages on this type of processors. But other kind of computing units, such as FPGAs, can be programmed directly with Clash, which can be compiled to native FPGA bitstreams. With this talk we pretend to create awareness of POLCA in the functional community, get feedback a create a bridge between imperative and functional programming worlds.'
